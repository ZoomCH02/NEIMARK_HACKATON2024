"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeforcesAPI = void 0;
const node_crypto_1 = __importDefault(require("node:crypto"));
const lodash_1 = __importDefault(require("lodash"));
const qs_1 = __importDefault(require("qs"));
const sha512Hex = (data) => node_crypto_1.default.createHash("sha512").update(data).digest("hex");
const AUTHORIZED_METHODS = ["user.friends"];
let credentials;
/**
 * Codeforces API
 */
exports.CodeforcesAPI = {
    setCredentials: (value) => {
        credentials = value;
    },
    call: async (method, params) => {
        if (!credentials && AUTHORIZED_METHODS.includes(method)) {
            throw new Error("Credentials are not set");
        }
        const data = {
            ...params,
            apiKey: credentials?.API_KEY,
            time: Math.floor(Date.now() / 1000),
        };
        // Generate a 6 character random string
        const rand = Math.random().toString(32).substring(2, 8);
        const sortedData = lodash_1.default.fromPairs(lodash_1.default.toPairs(data).sort());
        const queryString = qs_1.default.stringify(sortedData, { encode: false });
        const payload = `${rand}/${method}?${queryString}#${credentials?.API_SECRET}`;
        const query = qs_1.default.stringify({ ...data, apiSig: rand + sha512Hex(payload) });
        const response = await fetch(`https://codeforces.com/api/${method}?${query}`);
        return (await response.json());
    },
};
//# sourceMappingURL=codeforces.js.map